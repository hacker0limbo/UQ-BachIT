#!/usr/bin/env python3
"""
Assignment 1
CSSE1001/7030
Semester 2, 2018
"""

import string
from a1_support import is_word_english, is_numeric
from typing import List, Tuple

__author__ = "Weiting Yin"


# Write your functions here

def generate_ascii_lowercase() -> str:
    """(str) Return a 26 english letters in lowercase
        -> abcdefghijklmnopqrstuvwxyz
    """
    return string.ascii_lowercase[:]


def generate_ascii_uppercase() -> str:
    """(str) Return a 26 english letters in uppercase
        -> ABCDEFGHIJKLMNOPQRSTUVWXYZ
    """
    return string.ascii_uppercase[:]


def generate_ascii() -> str:
    """(str) Return a 52 english letters with both lowercase and uppercase
        -> abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
    """
    return string.ascii_letters[:]


def translate_text(target_str: str, base_str: str, shift_str: str) -> str:
    """ (str) Returns string be translated according to the template,
            template is generated by the last two parameters
    Parameter:
        target_str (str): the target str that needed to be translated
        base_str (str): the template base url
        shift_str (str): the shift str that make all the base_str in target_str replaced to this str
    """
    template = str.maketrans(base_str, shift_str)
    return target_str.translate(template)


def generate_shift_str(base_str: str, offset: int) -> str:
    """ (str) Returns the shifted str based on the offset

    Parameter:
        base_str (str): the base str that needed to be shifted
        offset (int): the shift number
    """
    shift_str = base_str[offset:] + base_str[:offset]
    return shift_str


def generate_shifted_ascii(offset: int) -> str:
    """ (str) Returns the shifted ascii str based on the offset

    Parameter:
        offset (int): the shift number
    """
    lowercase_ascii = generate_ascii_lowercase()
    uppercase_ascii = generate_ascii_uppercase()
    shifted_lowercase_ascii = generate_shift_str(lowercase_ascii, offset)
    shifted_uppercase_ascii = generate_shift_str(uppercase_ascii, offset)
    shifted_ascii = shifted_lowercase_ascii + shifted_uppercase_ascii
    return shifted_ascii


def remove_dash(dashed_list: list) -> List[str]:
    """(list) Returns the list that translate the dashed_list to no dash list

    Parameter:
        dashed_list (list): word list contains dash
    """
    result: List[str] = []
    word: str
    for word in dashed_list:
        if '-' in word:
            new_list: List[str] = word.split('-')
            result.extend(new_list)
        else:
            result.append(word)
    return result


def ignore_contractions(apostrophe_list: list) -> List[str]:
    """(list) Returns the list that remove all the words contains contractions

    Parameter:
        apostrophe_list (list): word list contains contractions
    """
    result: List[str] = apostrophe_list[:]
    word: str
    for word in result:
        if "'" in word:
            result.remove(word)
    return result


def get_alpha_word(word: str) -> str:
    """(str) return the str that only contains alpha letters

    Parameter:
        word (str): word that contains non-alpha letters
    """
    alpha_word: str = ''
    for letter in word:
        if letter.isalpha():
            alpha_word += letter
    return alpha_word


def cypher(text: str, offset: int) -> str:
    """ (str) Returns the cyphered text

    Parameter:
        text (int): the input text needed to be cyphered
        offset (int): the number of shift of each letter, between 1 and 25, inclusive
    """
    ascii_text: str = generate_ascii()
    original_text: str = text[:]
    cyphertext: str = ''
    for each_offset in range(1, 26):
        if offset == 0:
            shifted_ascii: str = generate_shifted_ascii(each_offset)
            cyphertext += f'\n  {each_offset:0=2d}: ' \
                          + translate_text(original_text, ascii_text, shifted_ascii)
        else:
            shifted_ascii: str = generate_shifted_ascii(offset)
            cyphertext += translate_text(original_text, ascii_text, shifted_ascii)
            break
    return cyphertext


def encrypt(text: str, offset: int) -> str:
    """ (str) Returns the encrypted text

    Parameter:
        text (int): the input text needed to be encrypted
        offset (int): the number of shift of each letter, between 1 and 25, inclusive
    """
    encrypted_text: str = cypher(text, offset)
    return encrypted_text


def decrypt(text: str, offset: int) -> str:
    """ (str) Returns the decrypted text

    Parameter:
        text (int): the input text needed to be decrypt
        offset (int): the number of shift of each letter, between 1 and 25, inclusive
    """
    decrypted_text: str = cypher(text, -offset)
    return decrypted_text


def find_encryption_offsets(encrypted_text: str) -> Tuple[int]:
    """ (tuple) Returns the offset
        which could make encrypted_text decrypted to a english text
        if no such offset, nothing will be append to the turple

    Parameter:
        encrypted_text (int): the input text that was encrypted
    """
    offsets: List[int] = []
    for offset in range(1, 26):
        decrypted_text: str = decrypt(encrypted_text, offset)
        decrypted_text_list: List[str] = [word for word in decrypted_text.split(' ')]
        decrypted_text_list = ignore_contractions(remove_dash(decrypted_text_list))
        decrypted_text_list: List[str] = list(map(get_alpha_word, decrypted_text_list))
        lower_word_list: List[str] = [word.lower() for word in decrypted_text_list]
        is_english_list: List[bool] = list(map(is_word_english, lower_word_list))
        if all(is_english_list):
            offsets.append(offset)
    return tuple(offsets)


def question_e() -> bool:
    """ (Bool) The function will
    show question a content and show relative result
    and then return True to represent question asking will continue

    Parameter:
        (void) No parameter, only process question
    """
    text_to_encrypt: str = input('Please enter some text to encrypt: ')
    offset: str = input('Please enter a shift offset (1-25): ')
    if is_numeric(offset):
        encrypted_text = encrypt(text_to_encrypt, int(offset))
        if offset == '0':
            print(f'The encrypted text is:{encrypted_text}')
        else:
            print(f'The encrypted text is: {encrypted_text}')
    print()
    return True


def question_d() -> bool:
    """ (Bool) The function will
    show question a content and show relative result
    and then return True to represent question asking will continue

    Parameter:
        (void) No parameter, only process question
    """
    text_to_encrypt: str = input('Please enter some text to decrypt: ')
    offset: str = input('Please enter a shift offset (1-25): ')
    if is_numeric(offset):
        decrypted_text = decrypt(text_to_encrypt, int(offset))
        if offset == '0':
            print(f'The decrypted text is:{decrypted_text}')
        else:
            print(f'The decrypted text is: {decrypted_text}')
    print()
    return True


def question_a() -> bool:
    """ (Bool) The function will
    show question a content and show relative result
    and then return True to represent question asking will continue

    Parameter:
        (void) No parameter, only process question
    """
    result = ''
    encrypted_text = input('Please enter some encrypted text: ')
    offsets: Tuple[int] = find_encryption_offsets(encrypted_text)
    if len(offsets) == 1:
        encryption_offset = ''.join(str(offsets[0]))
        decrypted_message = decrypt(encrypted_text, offsets[0])
        result += f'Encryption offset: {encryption_offset}\n' \
                  + f'Decrypted message: {decrypted_message}'
    elif len(offsets) > 1:
        multi_encryption_offsets = ', '.join(map(str, offsets))
        result += f"Multiple encryption offsets: {multi_encryption_offsets}"
    else:
        result += 'No valid encryption offset'
    print(result)
    print()
    return True


def question_q() -> bool:
    """ (Bool) print 'bye'
    and then return False to represent the program will be terminated

    Parameter:
        (void) No parameter, only process question
    """
    print('Bye!')
    return False


def show_question() -> str:
    """ (Str) The function will show all the questions and allow user to choose one
    The user choice will be returned

    Parameter:
        (void)
    """
    question = 'Please choose an option [e/d/a/q]:\n' \
               + '  e) Encrypt some text\n' \
               + '  d) Decrypt some text\n' \
               + '  a) Automatically decrypt English text\n' \
               + '  q) Quit\n' \
               + '> '
    user_option = input(question)
    return user_option


def do_question(user_option: str) -> bool:
    """ (Bool) The function will provide relevant answers according to each question
                if relevant question number is input, 'Invalid command' will pop up
                every question will continue show up unless user input q, wich will
                generate False in the result, and the loop will be terminated
    Parameter:
        (void)
    """
    continued = True
    options = {
        'e': question_e,
        'd': question_d,
        'a': question_a,
        'q': question_q,
    }
    if user_option in options.keys():
        continued: bool = options[user_option]()
    else:
        print('Invalid command\n')
    return continued


def show_title() -> None:
    """(Void)
    show the start title of the program

    Parameter:
    (void)
    """
    print('Welcome to the simple encryption tool!\n')


def process() -> None:
    """(Void)
    The function will process the program
    and decide whether to stop depends on user choice

    Parameter:
    (void)
    """
    while True:
        user_option = show_question()
        continued: bool = do_question(user_option)
        if not continued:
            break


def main() -> None:
    """ (void) The main function to show question and provide relevant value

    Parameter:
        (void)
    """
    show_title()
    process()


##################################################
# !! Do not change (or add to) the code below !! #
#
# This code will run the main function if you use
# Run -> Run Module  (F5)
# Because of this, a "stub" definition has been
# supplied for main above so that you won't get a
# NameError when you are writing and testing your
# other functions. When you are ready please
# change the definition of main above.
###################################################


if __name__ == '__main__':
    main()
