#!/usr/bin/env python3
"""
Assignment 1
CSSE1001/7030
Semester 2, 2018
"""

import sys
import string
from a1_support import is_word_english

__author__ = "Weiting Yin & 44623515"


# Write your functions here
def generate_ascii_lowercase() -> str:
    """(str) Return a 26 english letters in lowercase
        -> abcdefghijklmnopqrstuvwxyz
    """
    return string.ascii_lowercase[:]


def generate_ascii_uppercase() -> str:
    """(str) Return a 26 english letters in uppercase
        -> ABCDEFGHIJKLMNOPQRSTUVWXYZ
    """
    return string.ascii_uppercase[:]


def generate_ascii() -> str:
    """(str) Return a 52 english letters with both lowercase and uppercase
        -> abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
    """
    return string.ascii_letters[:]


def translate_text(target_str: str, base_str: str, shift_str: str) -> str:
    """ (str) Returns string be translated according to the template,
            template is generated by the last two parameters

    Parameter:
        target_str (str): the target str that needed to be translated
        base_str (str): the template base url
        shift_str (str): the shift str that make all the base_str in target_str replaced to this str
    """
    template = str.maketrans(base_str, shift_str)
    return target_str.translate(template)


def generate_shifted_ascii(offset: int) -> str:
    """ (str) Returns the shifted ascii str based on the offset

    Parameter:
        offset (int): the shift number
    """
    lowercase_ascii = generate_ascii_lowercase()
    uppercase_ascii = generate_ascii_uppercase()
    shifted_lowercase_ascii = lowercase_ascii[offset:] + lowercase_ascii[:offset]
    shifted_uppercase_ascii = uppercase_ascii[offset:] + uppercase_ascii[:offset]
    shifted_ascii = shifted_lowercase_ascii + shifted_uppercase_ascii
    return shifted_ascii


def cypher(text: str, offset: int) -> str:
    """ (str) Returns the cyphered text

    Parameter:
        text (int): the input text needed to be cyphered
        offset (int): the number of shift of each letter, between 1 and 25, inclusive
    """
    ascii_text = generate_ascii()
    original_text = text[:]
    cyphertext = ''
    for each_offset in range(1, 26):
        if offset == 0:
            shifted_ascii = generate_shifted_ascii(each_offset)
            cyphertext += f'\n{each_offset:0=2d}: ' + translate_text(original_text, ascii_text,
                                                                     shifted_ascii)
        else:
            shifted_ascii = generate_shifted_ascii(offset)
            cyphertext += translate_text(original_text, ascii_text, shifted_ascii)
            break
    return cyphertext


def encrypt(text: str, offset: int) -> str:
    """ (str) Returns the encrypted text

    Parameter:
        text (int): the input text needed to be encrypted
        offset (int): the number of shift of each letter, between 1 and 25, inclusive
    """
    encrypted_text = cypher(text, offset)
    return encrypted_text


def decrypt(text: str, offset: int) -> str:
    """ (str) Returns the decrypted text

    Parameter:
        text (int): the input text needed to be decrypt
        offset (int): the number of shift of each letter, between 1 and 25, inclusive
    """
    decrypted_text = cypher(text, -offset)
    return decrypted_text


def find_encryption_offsets(encrypted_text: str) -> tuple:
    """ (tuple) Returns the offset
        which could make encrypted_text decrypted to a english text
        if no such offset, nothing will be append to the turple

    Parameter:
        encrypted_text (int): the input text that was encrypted
    """
    offsets = []
    for offset in range(1, 26):
        decrypted_text_list = decrypt(encrypted_text, offset).split(' ')
        lower_word_list = [word.lower() for word in decrypted_text_list]
        is_english_list = map(is_word_english, lower_word_list)
        if all(is_english_list):
            offsets.append(offset)
    return tuple(offsets)


def question_e():
    """ (Void) The function will
    show question a content and show relative result

    Parameter:
        (void) No parameter, only process question
    """
    text_to_encrypt = input('Please enter some text to encrypt: ')
    offset = int(input('Please enter a shift offset (1-25): '))
    encrypted_text = encrypt(text_to_encrypt, offset)
    print(f'The encrypted text is: {encrypted_text}')


def question_d():
    """ (Void) The function will
    show question a content and show relative result

    Parameter:
        (void) No parameter, only process question
    """
    text_to_encrypt = input('Please enter some text to decrypt: ')
    offset = int(input('Please enter a shift offset (1-25): '))
    decrypted_text = decrypt(text_to_encrypt, offset)
    print(f'The decrypted text is: {decrypted_text}')


def question_a():
    """ (Void) The function will
    show question a content and show relative result

    Parameter:
        (void) No parameter, only process question
    """
    result = ''
    encrypted_text = input('Please enter some encrypted text: ')
    offsets = find_encryption_offsets(encrypted_text)
    if len(offsets) == 1:
        result += f"""Encryption offset: {''.join(str(offsets[0]))}
Decrypted message: {decrypt(encrypted_text, offsets[0])}"""
    elif len(offsets) > 1:
        result += f"Multiple encryption offsets: {', '.join(map(str, offsets))}"
    else:
        result += 'No valid encryption offset'
    print(result)


def question_q():
    """ (void) end the program

    Parameter:
        (void) No parameter, only process question
    """
    print('Bye!')
    sys.exit()


def show_question():
    """ (void) The function will show all the questions and allow user to choose one
    Parameter:
        (void)
    """
    question = """Please choose an option [e/d/a/q]:
e) Encrypt some text
d) Decrypt some text
a) Automatically decrypt English text
q) Quit
>"""
    user_option = input(question.rstrip() + ' ')
    return user_option


def do_question(user_option: str):
    """ (void) The function will provide relevant answers according to each question
                if relevant question number is input, 'Invalid command' will pop up
    Parameter:
        (void)
    """
    options = {
        'e': question_e,
        'd': question_d,
        'a': question_a,
        'q': question_q,
    }
    if user_option in options.keys():
        options[user_option]()
    else:
        print('Invalid command')
    print()


def main():
    """ (void) The main function to show question and provide relevant value

    Parameter:
        (void)
    """
    while True:
        user_option = show_question()
        do_question(user_option)


##################################################
# !! Do not change (or add to) the code below !! #
#
# This code will run the main function if you use
# Run -> Run Module  (F5)
# Because of this, a "stub" definition has been
# supplied for main above so that you won't get a
# NameError when you are writing and testing your
# other functions. When you are ready please
# change the definition of main above.
###################################################


if __name__ == '__main__':
    main()
